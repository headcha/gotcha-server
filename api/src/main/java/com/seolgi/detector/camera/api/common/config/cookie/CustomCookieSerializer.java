package com.seolgi.detector.camera.api.common.config.cookie;

import org.apache.commons.lang3.StringUtils;
import org.springframework.session.web.http.DefaultCookieSerializer;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

/**
 * This serializer obfuscates the session ID as seen by the client. On the server, the sessionID remains the same.
 * The session generated by Spring takes the form of a-b-c-d-e where a/b/c/d/e are hexadecimal strings.
 * Our obfuscation swaps a and e, then inserts randomly generated data at parts 1 and 5. The final product
 * looks like e-x-b-c-d-y-a, where x and y are random data generated for each request.
 *
 * 이 serializer는 클라이언트가 볼 수있는 세션 ID를 난독 화합니다. 서버에서 sessionID는 동일하게 유지됩니다. Spring에 의해 생성 된
 * 세션은 a-b-c-d-e 형식을 취하는데 여기서 a / b / c / d / e는 16 진수 문자열이다. 우리의 난독 화는 a와 e를 바꾼 다음 파트 1과 5에
 * 임의로 생성 된 데이터를 삽입합니다. 최종 제품은 e-x-b-c-d-y-a와 같이 표시됩니다. 여기서 x와 y는 각 요청에 대해 생성 된 임의의 데이터입니다.
 * (Google Translate)
 */
public class CustomCookieSerializer extends DefaultCookieSerializer{

    public static final String COOKIE_NAME = "congchoo-sid";

    @Override
    public List<String> readCookieValues(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        List<String> matchingCookieValues = new ArrayList<>();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (this.COOKIE_NAME.equals(cookie.getName())) {
                    String sessionId = cookie.getValue();
                    if(StringUtils.countMatches(sessionId, "-") > 4) {
                        List<String> idParts = new ArrayList<>(Arrays.asList(sessionId.split("-")));
                        idParts.remove(1);
                        idParts.remove(idParts.size() - 2);
                        Collections.swap(idParts, 0, idParts.size() - 1);
                        sessionId = String.join("-", idParts);
                    }

                    if (sessionId == null) {
                        continue;
                    }
                    matchingCookieValues.add(sessionId);
                }
            }
        }
        return matchingCookieValues;
    }

    @Override
    public void writeCookieValue(CookieValue cookieValue) {
        HttpServletRequest request = cookieValue.getRequest();
        HttpServletResponse response = cookieValue.getResponse();

        String cookieValueString = cookieValue.getCookieValue();
        if("".equals(cookieValueString) == false) {
            List<String> cookieParts = new ArrayList<>(Arrays.asList(cookieValueString.split("-")));
            Collections.swap(cookieParts, 0, cookieParts.size() - 1);
            cookieParts.add(1, Integer.toHexString(ThreadLocalRandom.current().nextInt()));
            cookieParts.add(cookieParts.size() - 1, Integer.toHexString(ThreadLocalRandom.current().nextInt()));
            cookieValueString = String.join("-", cookieParts);
        }

        Cookie sessionCookie = new Cookie(this.COOKIE_NAME, cookieValueString);
        sessionCookie.setSecure(false);
        sessionCookie.setPath(request.getContextPath() + "/");

        sessionCookie.setHttpOnly(true);

        if ("".equals(cookieValueString)) {
            sessionCookie.setMaxAge(0);
        } else {
            // the cookie is only written at time of session creation, so we rely on
            // session expiration rather than cookie expiration if remember me is enabled
            sessionCookie.setMaxAge(Integer.MAX_VALUE);
        }

        response.addCookie(sessionCookie);
    }
}
